---
title: "Zentralitätsmasse in R mit statnet berechnen"
author: "Schritt für Schritt Cheatsheet"
date: "Mario Angst"
output: html_document
---

## Vorbereitung

Was ist statnet? Ein Kompendium von R-Tools welche Netzwerkanalyse vereinfachen. Darum laden wir es zuerst. Keine Angst vor roten Warnungen, dies sind nur Package Informationen. Daher:

```{r, echo=T, warning=F, message=F}
library(statnet)
```

Was wir ebenfalls brauchen ist das Package GGally. In diesem ist _ggnet2_ enthalten, welches es uns erlaubt, einfach schöne Netzwerk-Grafiken zu erstellen.

```{r, echo=T, warning=F, message=F}
library(GGally)
```

ggnet2 ist schön dokumentiert unter https://briatte.github.io/ggnet/

## Objekte vom Typ network

Im Folgenden verwenden wir als Beispiel ein reduziertes Interaktionsnetzwerk aus unserem Kurs (bekannt aus dem Zentralitätsarbeitsblatt). Wir verwenden dazu eine Adjacency Matrix, die wir in ein Objekt namens _mat_ geschrieben haben.
```{r}
mat
```

Aus dieser Matrix erstellen wir zwei _network_ Objekte. Objekte vom Typ network sind eine spezifische Art in R Netzwerke zu speichern. Sie werden mit network() erstellt.
Wir erstellen ein gerichtetes Netzwerk-Objekt mit der Option directed = T, welches wir net_directed nennen.

```{r}
net_directed <- network(mat,directed = T) #make a directed network object
```

Mit ggnet2 können wir dieses Objekt nun plotten.

```{r}
ggnet2(net_directed, node.label = T, arrow.size = 3, arrow.gap = 0.05) #plot directed network
```

Mit der Option directed = F erstellen wir ein ungerichtetes Netzwerk-Objekt, welches wir ebenfalls mit ggnet2 plotten können.

```{r}
net_undirected <- network(mat,directed = F) #make an undirected network object
```
```{r}
ggnet2(net_undirected, node.label = T) #plot undirected network
```

Mit diesen Netzwerkobjekten können wir nun verschiedene Operationen durchführen indem wir sie in Funktionen füttern. Die erste Operation ist bereits oben abgebildet - wir können mittels plot() oder ggnet2() die Netzwerke grafisch darstellen. Wir können aber auch diverse Analyseschritte durchführen. 

## Dichte

Als erstes berechnen wir die Density/ Dichte des Netzwerks für das ungerichtete Netzwerk.Dafür benutzen wir die Funktion gden().
Wie wir gelernt haben ist es für die Berechnung der meisten Netzwerkmasse von Bedeutung, ob das Netzwerk gerichtet oder ungerichtet ist. Um dies der Berechnungsfunktion mitzuteilen gibt es in gden() den Parameter _mode_. Wenn wir diesen auf "graph" setzen berechnet gden() die Dichte anhand der Formel für ein ungerichtetes Netzwerk.

```{r}
gden(dat = net_undirected,mode = "graph") #calculate with gden function
```

Das Gleiche können wir auch für das gerichtete Netzwerk tun, indem wir den Parameter mode auf die Option "digraph" stellen.

```{r}
gden(net_directed,mode = "digraph")
```

Fast jede Funktion in R hat verschiedene Parameter, welche mit Kommas voneinander getrennt sind. Generell sind Funktionen in R verkürzt gesagt alle Befehle, auf die eine Klammer() folgt, in welche ihr ein Objekt eingebt, mit dem R etwas tut/ berechnet. In RStudio könnt ihr mit der Tab-Taste die Parameter einer Funktion aufrufen, während ihr am Schreiben seid. Mit ?Funktion könnt ihr immer alle Parameter einer Funktion und deren Optionen ansehen.

## Node-level Zentralitätsmasse

Wir berechnen nun die Degree-Zentralität jeder Node im Netzwerk mit dem Befehl degree() und tun dies für das ungerichtete Netzwerk. Wenn wir den degree Befeh einfach ausführen, erhalten wir einen Vektor des Degrees jeder Node.

```{r}
degree(net_undirected,gmode = "graph")
```

Wenn wir danach mit diesen Degree-Werten weiterarbeiten wollen, müssen wir sie allerdings noch in ein Objekt schreiben. Wir schreiben also den Vektor, welchen wir als Resultat der Degree-Berechnung erhalten in ein Objekt, welches wir _deg_ nennen.
```{r}
deg <- degree(net_undirected,gmode = "graph") #calculate a vector of degree values for all nodes in
```

Wir tun das Gleiche nun ebenfalls mit closeness und betweenness.

```{r}
clo <- closeness(net_undirected,gmode = "graph")
bet <- betweenness(mat,gmode = "graph")
```

Was bringt uns dies? Wir können nun zum Beispiel eine Liste aller Nodes im Netzwerk mitsamt ihren jeweiligen Degree, Closeness und Betweenness-Werten erstellen.

Dafür kombinieren wir alle drei Vektoren in einer Data Frame mit dem Befehl data.frame und benennen die Rows der Data Frame anhand der rownames unserer adjacency matrix.

```{r}
df <- data.frame(bet, clo, deg, row.names = rownames(mat))
round(df,digits = 2) #dieser Befehl rundet alle Einträge in df auf zwei Stellen.
```

Eine weitere Art, wie unsere Vektoren mit Zentralitätsmassen verwenden könnten, wäre eine Untersuchung davon, inwiefern die verschiedenen Masse miteinander korreliert sind. Die Funktion cor() erlaubt es uns, die Korrelation zwischen verschiedenen, gleich langen Vektoren zu untersuchen. Unsere Data Frame _df_ enthält drei Vektoren der gleichen Länge. Wir können sie also in cor() füttern.

```{r}
cor(df)
```

Das Resultat zeigt auf, dass die verschiedenen Zentralitätsmasse stark miteinander korreliert sind. Dies ist meistens der Fall.




## Globale Zentralisierungsmasse

Wir können die network-Objekte auch dazu verwenden, globale Zentralisierungsmasse zu berechnen. Dazu füttern wir sie in die Funktion centralization().
Die Funktion centralization() hat wiederum verschiedene Parameter. Wichtig für uns ist der Parameter _FUN_. Dieser erlaubt uns die Zentralitäts-Funktion zu wählen, aufgrund derer wir die Zentralisierung berechnen wollen. Hier können wir es beispielsweise für Degree-Zentralisierung tun.

```{r}
centralization(net_undirected, mode = "graph",FUN = "degree")
```

Oder aber auch für Betweenness, oder Closeness-Zentralisierung.
```{r}
centralization(net_undirected, mode = "graph",FUN = "betweenness")
centralization(net_undirected, mode = "graph",FUN = "closeness")
```
