
# A step by step guide to computing centrality measures in statnet

## Preparation

What is statnet? It's a compendium of R tools which greatly facilitate network analysis. That is why we load it first:

```{r, echo=T, warning=F, message=F}
library(statnet)
```

We also need the package GGally. GGally contains _ggnet2_, which allows us to create pretty network visualizations.

```{r, echo=T, warning=F, message=F}
library(GGally)
```

ggnet2 is beautifully documented under https://briatte.github.io/ggnet/

## Objekte vom Typ network

In the following, we will utilize the friendship network of the Swiss national soccer team. Let's quickly recall the adjacency matrix.


```{r, echo=F}
myel <- read.csv("bookdown_resources/nati_friends.csv", stringsAsFactors = FALSE, encoding = "UTF-8")
myel <- myel[myel$Receiver != "Alle",]

## create adjacency matrix

unique_names <- unique(c(myel$Sender, myel$Receiver))
friends_adjmat <- matrix(0, nrow = length(unique_names), ncol = length(unique_names))
colnames(friends_adjmat) <- unique_names
rownames(friends_adjmat) <- unique_names
friends_adjmat[cbind(myel$Sender,myel$Receiver)] <- 1

att <- read.csv("bookdown_resources/nati_atts.csv", stringsAsFactors = FALSE, encoding = "UTF-8")
att <- att[att$Name %in% unique_names,]
att <- att[match(att$Name, unique_names),]
```

```{r}
friends_adjmat[1:5,1:5]
```

We will create two _network_ objects out of this matrix. Objects of type network are a specific way to save networks in R. They are created using the function network().

We first create a directed network with the option directed = T, which we name net_directed.
Wir erstellen ein gerichtetes Netzwerk-Objekt mit der Option directed = T, welches wir net_directed nennen.

```{r}
net_directed <- network(friends_adjmat,directed = T) #make a directed network object
```

Let's plot the object with ggnet.

```{r}
ggnet2(net_directed, node.label = T, arrow.size = 3, arrow.gap = 0.05) #plot directed network
```

Using the option directed = F, we can create an undirected network object, which we can also plot with ggnet2.

```{r}
net_undirected <- network(friends_adjmat,directed = F) #make an undirected network object
```
```{r}
ggnet2(net_undirected, node.label = T) #plot undirected network
```

We can now do different operation on these network objects by feeding them into functions. The first operation is already depicted above. With plot() or ggnet2(), we can create network graphics. But we can go a long way beyond this and use more formalized ways of analyzing network structure.

A first operation we can do is to only use the largest connected component of the network for further calculation. This is done here to simplify interpretation.

```{r, results='hide'}
largest_component <- component.largest(net_undirected)
adj_mat_largest_comp <- net_undirected[largest_component, largest_component]
net_undirected <- network(adj_mat_largest_comp, directed = F)

adj_mat_largest_comp_directed <- net_directed[largest_component, largest_component]
net_directed <- network(adj_mat_largest_comp_directed, directed = T)
```

The network now looks like this - only the largest components remains.

```{r}
ggnet2(net_directed, node.label = T, arrow.size = 3, arrow.gap = 0.05) #plot directed network
```



## Density

First, let's compute the density of the undirected network. We can do this using the function gden(). For most network metrics, it is important if the network is directed or net. We can tell the function about this using the parameter _mode_. Setting mode to "graph", calculates density according to the formula for an undirected network.

```{r}
gden(dat = net_undirected,mode = "graph") #calculate with gden function
```

Setting mode to digraph, does the same for a directed network.

```{r}
gden(net_directed,mode = "digraph")
```


## Node-level centrality measures

Using the function degree(), we can now calculate the degree centrality of every mode in the network.
Using the degree function on the undirected network (remember that we have to specify "graph" again for this), we receive a vector of degree centralitiy for each node.

```{r}
degree(net_undirected,gmode = "graph")
```

To further work with these degree values, we have to write them into an object. Thus, we write the vector we receive by running degree into an R object we call deg.

```{r}
deg <- degree(net_undirected,gmode = "graph") #calculate a vector of degree values for all nodes in
```

Let's do the same things for closeness and betweenness.

```{r}
clo <- closeness(net_undirected,gmode = "graph", )
bet <- betweenness(net_undirected,gmode = "graph")
```

What do we do with this now. For example, we can create a data frame of all nodes in the undirected network with their respective degree, closeness and betweennes values.

To do so, we combine the three vectors in a data frame.

```{r}
centrality_df <- data.frame(bet, clo, deg, row.names = rownames(adj_mat_largest_comp))
round(centrality_df,digits = 2) #just a bit of rounding.
```

Let's now size the nodes in our visualization according to betweenness. Who holds the network together?

```{r}
ggnet2(net_undirected, node.label = T, node.size = centrality_df$bet) #plot undirected network
```

We can now for example look at correlation between our centrality measures (these are usually quite high).

```{r}
cor(df)
```

Das Resultat zeigt auf, dass die verschiedenen ZentralitÃ¤tsmasse stark miteinander korreliert sind. Dies ist meistens der Fall.




## Globale Zentralisierungsmasse

We can also use the network objects to compute global centralization measures. To do so wie use the function centralization(). The parameter _FUN_ in centralization() allows to specify the centrality measure to base our centralization score on. For example, we can choose degree:

```{r}
centralization(net_undirected, mode = "graph",FUN = "degree")
```

But also, as before, betweenness and closeness.
```{r}
centralization(net_undirected, mode = "graph",FUN = "betweenness")
centralization(net_undirected, mode = "graph",FUN = "closeness")
```
