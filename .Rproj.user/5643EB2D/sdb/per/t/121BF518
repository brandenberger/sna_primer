{
    "collab_server" : "",
    "contents" : "\n\n# dependencies:\nsource(\"create issue issue matrix.R\")\n\nverification_recoding <- read.csv(\"verification_recoding.csv\", encoding = \"UTF-8\")\n\ncodebook_rename <- read.csv(file = \"codebook_issues_projectgroups_projects.csv\", stringsAsFactors = F, encoding = \"UTF-8\")\nrename_based_on_codebook <- Vectorize(\n  function(x){\n    if (x %in% codebook_rename$german){\n      rename_value <- codebook_rename$coded[codebook_rename$german == x]\n      return(rename_value[1]) #return first value\n    }\n    if (is.na(x) | x == \"\"){\n      return(NA)\n    }\n    else\n      return(paste(as.character(x),\" not found in codebook\"))\n  } \n)\n\nrownames(document_issue_mat)\n\nverification_recoding[,3:ncol(verification_recoding)] <- apply(verification_recoding[,3:ncol(verification_recoding)],2,rename_based_on_codebook)\nverification_recoding$Artikel_id <- sub(x = as.character(verification_recoding$Artikel_id),\n                                          pattern = \".txt\",replacement = \"\")\n# rownames(document_issue_mat) <- sub(x = rownames(document_issue_mat),\n#                                     pattern = \".txt\",replacement = \"\")\n\n\n\n# subset document issue mat\n\nmario_mat <- document_issue_mat[rownames(document_issue_mat) %in% verification_recoding$Artikel_id[\n                                  verification_recoding$Codierer != \"Lenzi\"],]\n\n# add rows coded with no issues to mario_mat\nrows_to_add <- verification_recoding$Artikel_id[!(verification_recoding$Artikel_id[verification_recoding$Codierer != \"Lenzi\"] %in% \n                                                    rownames(document_issue_mat))]\nmario_mat <- rbind(mario_mat, matrix(0,nrow = length(rows_to_add), ncol = ncol(mario_mat)))\nrownames(mario_mat) <- c(rownames(mario_mat)[1:(length(rownames(mario_mat))-length(rows_to_add))],rows_to_add)\n\ncontrol_adjlist <- verification_recoding[verification_recoding$Codierer != \"Lenzi\",2:ncol(verification_recoding)]\ncontrol_el <-\n  cbind(\n    c(apply(control_adjlist,1,function(x) rep(x[1], length(x)-1))),\n    c(apply(control_adjlist,1,function(x) x[2:length(x)]))  \n  )\ncontrol_el <- control_el[!(is.na(control_el[,2])),]\ncontrol_el[,2] <- sub(x = control_el[,2],pattern = \"landdenkm\",replacement = \"landschafts_denkmalschutz\")\ncontrol_mat <- mario_mat\ncontrol_mat[,] <- 0\ncontrol_el_subset <- control_el[control_el[,1] %in% rownames(control_mat),]\ncontrol_mat[control_el_subset] <- 1\n\ntable(mario_mat == control_mat)\ntable(mario_mat - control_mat)\ntable(mario_mat * control_mat)\n\nissue_diffs_list <-\nlapply(c(1:nrow(control_mat)), function(x) colnames(control_mat)[(control_mat[x,] != mario_mat[x,])])\ntable(unlist(issue_diffs_list))\n\nissue_in_mario_not_in_control <-\n  lapply(c(1:nrow(control_mat)), function(x) colnames(control_mat)[mario_mat[x,] == 1 & control_mat[x,] == 0])\ntable(unlist(issue_in_mario_not_in_control))\n\nissue_in_control_not_in_mario <-\n  lapply(c(1:nrow(control_mat)), function(x) colnames(control_mat)[mario_mat[x,] == 0 & control_mat[x,] == 1])\ntable(unlist(issue_in_control_not_in_mario))\n\nissue_in_both <-\n  lapply(c(1:nrow(control_mat)), function(x) colnames(control_mat)[mario_mat[x,] == 1 & control_mat[x,] == 1])\ntable(unlist(issue_in_both))\n  \ncomps_list <-\nlapply(c(1:nrow(control_mat)), function(x) {\n control <- factor(control_mat[x,],levels = c(0,1))\n mario <- factor(mario_mat[x,],levels = c(0,1))\n table(control,mario)\n})\n       \nReduce(\"+\",comps_list)\n\ntable(unlist(lapply(issue_diffs_list, length)))\n\n# ----------- compare nets derived from both ------\n\npar(mfrow(c(1,2)))\n\nmario_bip <- t(mario_mat) %*% mario_mat\nggnet2(network(mario_bip), label = T, size = \"degree\", size.min = 1)\n\ncontrol_bip <- t(control_mat) %*% control_mat\nggnet2(network(control_bip), label = T, size = \"degree\", size.min = 1)\n",
    "created" : 1524058926086.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "51842695",
    "id" : "121BF518",
    "lastKnownWriteTime" : 1522935972,
    "last_content_update" : 1522935972,
    "path" : "~/Documents/GitHub/Water-Policy-Issue-Links/Machine learning approach/Issue identification/Verification analysis.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}