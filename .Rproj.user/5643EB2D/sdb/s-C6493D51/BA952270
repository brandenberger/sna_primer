{
    "collab_server" : "",
    "contents" : "# Network data: how to store and use network data {#nwdata}\n## Different formats to store network data\n\n```{r, echo=FALSE, warning=FALSE, message=FALSE}\nlibrary(statnet)\nlibrary(ggplot2)\nlibrary(GGally)\nlibrary(scales)\n```\n\nRelational data consist of nodes and edges between these nodes. Data on the nodes---nodal attributes---can be stored in the conventional way of storing observational data: in a data frame where each row corresponds to each node (observation) in the network and columns to variables (eg. gender). \nThe edges that make up a network need to be stored in a slightly more complex manner. \n\nTake the following network:\n\n```{r, echo=FALSE}\nmyel <- read.csv(\"bookdown_resources/nati_friends.csv\", stringsAsFactors = FALSE, encoding = \"UTF-8\")\nmyel <- myel[myel$Receiver != \"Alle\",]\n\n## create adjacency matrix\n\nunique_names <- unique(c(myel$Sender, myel$Receiver))\nfriends_adjmat <- matrix(0, nrow = length(unique_names), ncol = length(unique_names))\ncolnames(friends_adjmat) <- unique_names\nrownames(friends_adjmat) <- unique_names\nfriends_adjmat[cbind(myel$Sender,myel$Receiver)] <- 1\n\natt <- read.csv(\"bookdown_resources/nati_atts.csv\", stringsAsFactors = FALSE, encoding = \"UTF-8\")\natt <- att[att$Name %in% unique_names,]\natt <- att[match(att$Name, unique_names),]\n## plot the network\nggnet2(friends_adjmat,\n       label = TRUE,\n       arrow.size = 4, arrow.gap = 0.04, \n       node.color = att$Position)\n```\n\nTo store the network data leading to the network plot, the sender and target nodes of each edge in the network have to be recorded. There are multiple ways of storing network data. The simplest form is called a `edgelist`, where each row in a data set corresponds to a tie in the network: \n\n```{r, echo=FALSE}\nmyel\n```\n\nHere the rows correspond to the edges in the network, the columns correspond to sender nodes `myel[,1]` and target nodes `myel[,2]`.\n\nAn alternative way of storing network data is by creating a matrix with all unique nodes in the rows as well as in the columns: \n\n```{r, echo=FALSE}\nfriends_adjmat[1:10,1:10]\n```\n\nHere, the network information is stored less efficiently but more intuitively: Every possible tie in a network is listed in the data set, for instance sender `a` tying to target `b`. If this tie exists, if\n`(a, b)` are indeed linked in the network, the matrix alotts them a 1. If `(a, b)` are not linked, they receive a 0 in the adjacency matrix.\n\nA third way of storing network data is through adjacency lists. They combine both features of the edge list and of the adjacency matrix: \n\n```{r, echo = FALSE}\nadj_list <- apply(rbind(colnames(friends_adjmat),friends_adjmat), 2, function(x) ifelse(x == 1,x[1],\"\"))\nadj_list <- cbind(rownames(adj_list),apply(adj_list, 1, function(x) paste(x[x !=\"\"], collapse = \",\")))\nrownames(adj_list) <- NULL\nadj_list[-1,]\n```\n\n\nAs mentioned above, nodal attributes can be stored in a data frame with row corresponding to unique nodes and columns to variables: \n\n```{r, echo=FALSE}\natt\n```\n\n## Dealing with network data in R\n\n### Storing network data using edge lists\n\n\n\n\n\n```{block, type ='task'}\nRead in the network data of the Swiss national socer team.\n```\n\n### Converting an edge list to adjacency matrix\n\n\n\n### Storing nodal attributes the right way\n\n\n\n### The network object from the `statnet`-package\n\n\n\n## Different Network types: one-mode and two-mode networks\n\n```{r, echo=FALSE}\ntwomode_el <- read.csv(\"bookdown_resources/nati_teams.csv\", stringsAsFactors = FALSE, encoding = \"UTF-8\")\n\nunique_players <- unique(twomode_el$Player)\nunique_teams <- unique(twomode_el$Team)\nbip_mat <- matrix(0, nrow = length(unique_players), ncol = length(unique_teams))\ncolnames(bip_mat) <- unique_teams\nrownames(bip_mat) <- unique_players\nbip_mat[cbind(twomode_el$Player,twomode_el$Team)] <- 1\n\ncol = c(\"actor\" = \"forest green\", \"event\" = \"light blue\")\nggnet2(network(bip_mat, matrix.type = \"bipartite\"), \n       label = TRUE, palette = col,\n       color = \"mode\", label.size = 2.5)\n\n```\n\nA adjacency matrix for a two-mode network is rectangular.\n\n```{r, echo=FALSE}\nbip_mat[1:4,1:7]\n```\n\nA projection onto a one-mode network can be achieved by multiplying the rectangular matrix by its transpose.\n\n```{r}\none_mode_projection <- bip_mat %*% t(bip_mat)\ndiag(one_mode_projection) <- 0 #exclude self-ties\none_mode_projection[1:10,1:10] #look at the first 10 players\n```\n\n```{r}\nggnet2(network(one_mode_projection),\n       label = TRUE)\n```\n\n\n## Network visualization\n\n### A word of warning\n\nNetwork visualizations are at the same time pretty and dangerous. Be aware that nodes will always be placed on a canvas through an algorithm. The choice of a different algorithm can lead to a vastly different illustration. It is thus easy to convey substantive results that are just artefacts of the visualization procedure, for example regarding the centrality of actors. It is in your responsibility to use visualization to augment, not distort interpretation. If you read a network study engaging in \"visual interpretation\" - look for the numbers. Do they back up the story?\n\n### Resources for visualization\n\nFor pretty graphs in R, ggnet2 is hard to beat. https://briatte.github.io/ggnet/\n\nFor more advanced (and even prettier) visualizations, Gephi is a dedicated open source project (although somewhat buggy). https://gephi.org/\n\n\n",
    "created" : 1521636680675.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2669687860",
    "id" : "BA952270",
    "lastKnownWriteTime" : 1523525168,
    "last_content_update" : 1523525168502,
    "path" : "~/Documents/GitHub/sna_primer/2_network_data.Rmd",
    "project_path" : "2_network_data.Rmd",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}