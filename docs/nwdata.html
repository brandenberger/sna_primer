<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Social Network Analysis Primer</title>
  <meta name="description" content="Social Network Analysis Primer">
  <meta name="generator" content="bookdown 0.5 and GitBook 2.6.7">

  <meta property="og:title" content="Social Network Analysis Primer" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Social Network Analysis Primer" />
  
  
  

<meta name="author" content="Mario Angst and Laurence Brandenberger">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="intro.html">
<link rel="next" href="a-step-by-step-guide-to-computing-centrality-measures-in-statnet.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
<link rel="stylesheet" href="font-awesome.min.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> A Guite to Social Network Analysis</a><ul>
<li class="chapter" data-level="1.1" data-path="index.html"><a href="index.html#goal"><i class="fa fa-check"></i><b>1.1</b> Goal</a></li>
<li class="chapter" data-level="1.2" data-path="index.html"><a href="index.html#chapters"><i class="fa fa-check"></i><b>1.2</b> Chapters</a></li>
<li class="chapter" data-level="1.3" data-path="index.html"><a href="index.html#textblocks"><i class="fa fa-check"></i><b>1.3</b> Textblocks</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>2</b> Introduction: Social Network Analysis - A primer for sport scientists.</a><ul>
<li class="chapter" data-level="2.1" data-path="intro.html"><a href="intro.html#relational-data-in-sports"><i class="fa fa-check"></i><b>2.1</b> Relational data in sports</a></li>
<li class="chapter" data-level="2.2" data-path="intro.html"><a href="intro.html#network-phenomena-global-and-individual-levels"><i class="fa fa-check"></i><b>2.2</b> Network phenomena: Global and individual levels</a></li>
<li class="chapter" data-level="2.3" data-path="intro.html"><a href="intro.html#networks-as-independent-variables"><i class="fa fa-check"></i><b>2.3</b> Networks as independent variables</a><ul>
<li class="chapter" data-level="2.3.1" data-path="intro.html"><a href="intro.html#example-english-soccer-teams"><i class="fa fa-check"></i><b>2.3.1</b> Example: English soccer teams</a></li>
<li class="chapter" data-level="2.3.2" data-path="intro.html"><a href="intro.html#example-something-with-individual-level-dependent-variable"><i class="fa fa-check"></i><b>2.3.2</b> Example: something with individual-level dependent variable</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="intro.html"><a href="intro.html#networks-as-dependent-variables"><i class="fa fa-check"></i><b>2.4</b> Networks as dependent variables</a><ul>
<li class="chapter" data-level="2.4.1" data-path="intro.html"><a href="intro.html#example"><i class="fa fa-check"></i><b>2.4.1</b> Example:</a></li>
</ul></li>
<li class="chapter" data-level="2.5" data-path="intro.html"><a href="intro.html#setting-boundaries"><i class="fa fa-check"></i><b>2.5</b> Setting boundaries</a></li>
<li class="chapter" data-level="2.6" data-path="intro.html"><a href="intro.html#conclusion-a-checklist-to-inform-your-research-design"><i class="fa fa-check"></i><b>2.6</b> Conclusion: A checklist to inform your research design</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="nwdata.html"><a href="nwdata.html"><i class="fa fa-check"></i><b>3</b> Network data: how to store and use network data</a><ul>
<li class="chapter" data-level="3.1" data-path="nwdata.html"><a href="nwdata.html#different-formats-to-store-network-data"><i class="fa fa-check"></i><b>3.1</b> Different formats to store network data</a></li>
<li class="chapter" data-level="3.2" data-path="nwdata.html"><a href="nwdata.html#dealing-with-network-data-in-r"><i class="fa fa-check"></i><b>3.2</b> Dealing with network data in R</a><ul>
<li class="chapter" data-level="3.2.1" data-path="nwdata.html"><a href="nwdata.html#reading-in-data-stored-in-an-edge-list"><i class="fa fa-check"></i><b>3.2.1</b> Reading in data stored in an edge list</a></li>
<li class="chapter" data-level="3.2.2" data-path="nwdata.html"><a href="nwdata.html#converting-an-edge-list-to-adjacency-matrix"><i class="fa fa-check"></i><b>3.2.2</b> Converting an edge list to adjacency matrix</a></li>
<li class="chapter" data-level="3.2.3" data-path="nwdata.html"><a href="nwdata.html#storing-nodal-attributes-the-right-way"><i class="fa fa-check"></i><b>3.2.3</b> Storing nodal attributes the right way</a></li>
<li class="chapter" data-level="3.2.4" data-path="nwdata.html"><a href="nwdata.html#the-network-object-from-the-statnet-package"><i class="fa fa-check"></i><b>3.2.4</b> The network object from the <code>statnet</code>-package</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="nwdata.html"><a href="nwdata.html#different-network-types-one-mode-and-two-mode-networks"><i class="fa fa-check"></i><b>3.3</b> Different Network types: one-mode and two-mode networks</a></li>
<li class="chapter" data-level="3.4" data-path="nwdata.html"><a href="nwdata.html#network-visualization"><i class="fa fa-check"></i><b>3.4</b> Network visualization</a><ul>
<li class="chapter" data-level="3.4.1" data-path="nwdata.html"><a href="nwdata.html#a-word-of-warning"><i class="fa fa-check"></i><b>3.4.1</b> A word of warning</a></li>
<li class="chapter" data-level="3.4.2" data-path="nwdata.html"><a href="nwdata.html#resources-for-visualization"><i class="fa fa-check"></i><b>3.4.2</b> Resources for visualization</a></li>
<li class="chapter" data-level="3.4.3" data-path="nwdata.html"><a href="nwdata.html#a-brief-overview-over-ggnet2"><i class="fa fa-check"></i><b>3.4.3</b> A brief overview over ggnet2()</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="a-step-by-step-guide-to-computing-centrality-measures-in-statnet.html"><a href="a-step-by-step-guide-to-computing-centrality-measures-in-statnet.html"><i class="fa fa-check"></i><b>4</b> A step by step guide to computing centrality measures in statnet</a><ul>
<li class="chapter" data-level="4.1" data-path="a-step-by-step-guide-to-computing-centrality-measures-in-statnet.html"><a href="a-step-by-step-guide-to-computing-centrality-measures-in-statnet.html#preparation"><i class="fa fa-check"></i><b>4.1</b> Preparation</a></li>
<li class="chapter" data-level="4.2" data-path="a-step-by-step-guide-to-computing-centrality-measures-in-statnet.html"><a href="a-step-by-step-guide-to-computing-centrality-measures-in-statnet.html#objekte-vom-typ-network"><i class="fa fa-check"></i><b>4.2</b> Objekte vom Typ network</a></li>
<li class="chapter" data-level="4.3" data-path="a-step-by-step-guide-to-computing-centrality-measures-in-statnet.html"><a href="a-step-by-step-guide-to-computing-centrality-measures-in-statnet.html#create-adjacency-matrix"><i class="fa fa-check"></i><b>4.3</b> create adjacency matrix</a></li>
<li class="chapter" data-level="4.4" data-path="a-step-by-step-guide-to-computing-centrality-measures-in-statnet.html"><a href="a-step-by-step-guide-to-computing-centrality-measures-in-statnet.html#density"><i class="fa fa-check"></i><b>4.4</b> Density</a></li>
<li class="chapter" data-level="4.5" data-path="a-step-by-step-guide-to-computing-centrality-measures-in-statnet.html"><a href="a-step-by-step-guide-to-computing-centrality-measures-in-statnet.html#node-level-centrality-measures"><i class="fa fa-check"></i><b>4.5</b> Node-level centrality measures</a></li>
<li class="chapter" data-level="4.6" data-path="a-step-by-step-guide-to-computing-centrality-measures-in-statnet.html"><a href="a-step-by-step-guide-to-computing-centrality-measures-in-statnet.html#global-centrality-measures"><i class="fa fa-check"></i><b>4.6</b> Global centrality measures</a></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Social Network Analysis Primer</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="nwdata" class="section level1">
<h1><span class="header-section-number">3</span> Network data: how to store and use network data</h1>
<div id="different-formats-to-store-network-data" class="section level2">
<h2><span class="header-section-number">3.1</span> Different formats to store network data</h2>
<p>Relational data consist of nodes and edges between these nodes. Data on the nodes—nodal attributes—can be stored in the conventional way of storing observational data: in a data frame where each row corresponds to each node (observation) in the network and columns to variables (eg. gender). The edges that make up a network need to be stored in a slightly more complex manner.</p>
<p>Take the following network of friendship relations between members of the Swiss national soccer team, leading up to the 2014 world championship. Players were asked in a series of interviews with each player in Neue Zürcher Zeitung about their friends in the team. This information was used to create a network dataset for illustrative purposes. <a href="https://www.nzz.ch/sport/wm-2014/portraetserie-der-schweizer-nationalspieler-1.18315579" class="uri">https://www.nzz.ch/sport/wm-2014/portraetserie-der-schweizer-nationalspieler-1.18315579</a></p>
<div class="figure"><span id="fig:trialfriendsadjmat"></span>
<img src="mainimages/trialfriendsadjmat-1.png" alt="Friendship relations between members of the Swiss national soccer team" width="672" />
<p class="caption">
Figure 3.1: Friendship relations between members of the Swiss national soccer team
</p>
</div>
<p>To store the network data leading to the network plot, the sender and target nodes of each edge in the network have to be recorded. There are multiple ways of storing network data. The simplest form is called a <code>edgelist</code>, where each row in a data set corresponds to a tie in the network:</p>
<pre><code>##          Sender     Receiver
## 2    Gavranovic        Drmic
## 3    Gavranovic    Seferovic
## 4          Lang       Sommer
## 5          Lang        Schär
## 6          Lang    Seferovic
## 7          Lang     Barnetta
## 8          Lang        Drmic
## 9         Bürki         Lang
## 10        Schär      Stocker
## 11       Sommer      Stocker
## 12      Stocker     Benaglio
## 13      Stocker     Barnetta
## 14      Stocker        Schär
## 15      Stocker       Sommer
## 16      Stocker         Lang
## 17      Shaqiri      Mehmedi
## 18     Benaglio Lichtsteiner
## 20        Xhaka    Rodriguez
## 22 Lichtsteiner     Benaglio
## 23    Rodriguez        Xhaka
## 27     Dzemaili      Mehmedi
## 28     Dzemaili      Shaqiri
## 29     Dzemaili      Behrami
## 31      Mehmedi      Shaqiri
## 32     Senderos      Ziegler
## 33     Senderos      Behrami
## 34      Behrami     Senderos</code></pre>
<p>Here the rows correspond to the edges in the network, the columns correspond to sender nodes <code>myel[,1]</code> and target nodes <code>myel[,2]</code>.</p>
<p>An alternative way of storing network data is by creating an adjacency matrix with all unique nodes in the rows as well as in the columns:</p>
<pre><code>##              Gavranovic Lang Bürki Schär Sommer Stocker Shaqiri Benaglio
## Gavranovic            0    0     0     0      0       0       0        0
## Lang                  0    0     0     1      1       0       0        0
## Bürki                 0    1     0     0      0       0       0        0
## Schär                 0    0     0     0      0       1       0        0
## Sommer                0    0     0     0      0       1       0        0
## Stocker               0    1     0     1      1       0       0        1
## Shaqiri               0    0     0     0      0       0       0        0
## Benaglio              0    0     0     0      0       0       0        0
## Xhaka                 0    0     0     0      0       0       0        0
## Lichtsteiner          0    0     0     0      0       0       0        1
##              Xhaka Lichtsteiner
## Gavranovic       0            0
## Lang             0            0
## Bürki            0            0
## Schär            0            0
## Sommer           0            0
## Stocker          0            0
## Shaqiri          0            0
## Benaglio         0            1
## Xhaka            0            0
## Lichtsteiner     0            0</code></pre>
<p>Here, every possible tie in a network is listed in the data set, for instance sender <code>a</code> tying to target <code>b</code>. If this tie exists, if <code>(a, b)</code> are indeed linked in the network, the matrix alotts them a 1. If <code>(a, b)</code> are not linked, they receive a 0 in the adjacency matrix. This way of storing network data also preserves the direction of the tie. Entries in the lower triangle of the matrix specify a tie from row entry to column entry and vice versa for the upper triangle. For large networks, storing data in adjacency matrices can become inefficient, as a lot of information is redundant (non-existing ties). However, many ways of computing network statistics operate directly on the adjaceny matrix.</p>
<p>A third way of storing network data is through adjacency lists. Adjacency list specify a sender first and then list all receivers. They are the most efficient format for gathering data in the field or transcribing/ entering data by hand.</p>
<pre><code>##       [,1]           [,2]                                   
##  [1,] &quot;Gavranovic&quot;   &quot;Drmic,Seferovic&quot;                      
##  [2,] &quot;Lang&quot;         &quot;Schär,Sommer,Drmic,Seferovic,Barnetta&quot;
##  [3,] &quot;Bürki&quot;        &quot;Lang&quot;                                 
##  [4,] &quot;Schär&quot;        &quot;Stocker&quot;                              
##  [5,] &quot;Sommer&quot;       &quot;Stocker&quot;                              
##  [6,] &quot;Stocker&quot;      &quot;Lang,Schär,Sommer,Benaglio,Barnetta&quot;  
##  [7,] &quot;Shaqiri&quot;      &quot;Mehmedi&quot;                              
##  [8,] &quot;Benaglio&quot;     &quot;Lichtsteiner&quot;                         
##  [9,] &quot;Xhaka&quot;        &quot;Rodriguez&quot;                            
## [10,] &quot;Lichtsteiner&quot; &quot;Benaglio&quot;                             
## [11,] &quot;Rodriguez&quot;    &quot;Xhaka&quot;                                
## [12,] &quot;Dzemaili&quot;     &quot;Shaqiri,Mehmedi,Behrami&quot;              
## [13,] &quot;Mehmedi&quot;      &quot;Shaqiri&quot;                              
## [14,] &quot;Senderos&quot;     &quot;Behrami,Ziegler&quot;                      
## [15,] &quot;Behrami&quot;      &quot;Senderos&quot;                             
## [16,] &quot;Drmic&quot;        &quot;&quot;                                     
## [17,] &quot;Seferovic&quot;    &quot;&quot;                                     
## [18,] &quot;Barnetta&quot;     &quot;&quot;                                     
## [19,] &quot;Ziegler&quot;      &quot;&quot;</code></pre>
<p>As mentioned above, nodal attributes can be stored in a data frame with row corresponding to unique nodes and columns to variables:</p>
<pre><code>##            Name    Position
## 2    Gavranovic     Stürmer
## 3          Lang Verteidiger
## 5         Bürki      Goalie
## 6         Schär Verteidiger
## 7        Sommer      Goalie
## 8       Stocker  Mittelfeld
## 9       Shaqiri     Stürmer
## 10     Benaglio      Goalie
## 12        Xhaka  Mittelfeld
## 14 Lichtsteiner Verteidiger
## 15    Rodriguez Verteidiger
## 20     Barnetta  Mittelfeld
## 17      Mehmedi     Stürmer
## 18     Senderos Verteidiger
## 19      Behrami  Mittelfeld
## 22     Dzemaili  Mittelfeld
## 23    Seferovic     Stürmer
## 16        Drmic     Stürmer
## 21      Ziegler Verteidiger</code></pre>
</div>
<div id="dealing-with-network-data-in-r" class="section level2">
<h2><span class="header-section-number">3.2</span> Dealing with network data in R</h2>
<div id="reading-in-data-stored-in-an-edge-list" class="section level3">
<h3><span class="header-section-number">3.2.1</span> Reading in data stored in an edge list</h3>
<p>Since edge lists (or adjacency lists) are the most efficient way of storing your data, we urge you to compile your network data in excel/txt-file using the sender-target columns for individual network ties.</p>
<p>Reading in your data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">myel &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="dt">file =</span> <span class="st">&quot;myedgelist.csv&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;;&quot;</span>, <span class="dt">header =</span> <span class="ot">TRUE</span>)</code></pre></div>
<div class="rmdtask">
<p>
Read in the network data of the Swiss national socer team.
</p>
</div>
</div>
<div id="converting-an-edge-list-to-adjacency-matrix" class="section level3">
<h3><span class="header-section-number">3.2.2</span> Converting an edge list to adjacency matrix</h3>
<p>Next you’ll need to determine how many unique nodes you have in your network:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mynodes &lt;-<span class="st"> </span><span class="kw">unique</span>(<span class="kw">c</span>(myel<span class="op">$</span>sender, myel<span class="op">$</span>target))</code></pre></div>
<p>Once you have specified a vector with all the unique names of the nodes in your network, you can create an empty matrix (empty = filled with zeros) and label the columns and rows accordingly:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mat &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>, <span class="dt">nrow =</span> <span class="kw">length</span>(mynodes), <span class="dt">ncol =</span> <span class="kw">length</span>(mynodes))
<span class="kw">colnames</span>(mat) &lt;-<span class="st"> </span>mynodes
<span class="kw">rownames</span>(mat) &lt;-<span class="st"> </span>mynodes</code></pre></div>
<p>Next you can fill your empty matrix with the ties reported in your egelist:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mat[<span class="kw">cbind</span>(myel<span class="op">$</span>sender, myel<span class="op">$</span>target)] &lt;-<span class="st"> </span><span class="dv">1</span></code></pre></div>
</div>
<div id="storing-nodal-attributes-the-right-way" class="section level3">
<h3><span class="header-section-number">3.2.3</span> Storing nodal attributes the right way</h3>
<p>Once you have prepared your adjacency list, you can create your nodal attribute data frame.</p>
<div class="rmdwrong">
<p>
Never use an attribute data frame without having made sure that the rownames of your adjacency matrix match the rows in your attribute file!
</p>
</div>
<p>You can either create a new data frame that contains a variable with the unique nodes, or you can sort a given attribute file so that the rows reflect the same people in the attribute file as well as in the adjacency matrix.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dt &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="dt">file =</span> <span class="st">&quot;attributes.csv&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;;&quot;</span>, <span class="dt">header =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p>Let’s assume your data frame contains a variable <code>nodeID</code> with all unique node names. Then you can check if your attribute file matches the adjacency matrix:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">identical</span>(att<span class="op">$</span>nodeID, <span class="kw">rownames</span>(mat))</code></pre></div>
<p>If they match, you can proceed. If they don’t match, you’ll have to sort your data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">att &lt;-<span class="st"> </span>att[att<span class="op">$</span>nodeID <span class="op">%in%</span><span class="st"> </span>mynodes,]
## or: 
att &lt;-<span class="st"> </span>att[att<span class="op">$</span>nodeID <span class="op">%in%</span><span class="st"> </span><span class="kw">rownames</span>(mat),]
## or: 
att &lt;-<span class="st"> </span>att[<span class="kw">match</span>(att<span class="op">$</span>nodeID, mynodes),]
## or: 
att &lt;-<span class="st"> </span>att[<span class="kw">match</span>(att<span class="op">$</span>nodeID, <span class="kw">rownames</span>(mat)),]</code></pre></div>
<p>or create a new data frame:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">att &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">nodeID =</span> <span class="kw">rownames</span>(mat))</code></pre></div>
<p>and then match variables from your original attributes file to your new attribute file:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">att<span class="op">$</span>newVariable &lt;-<span class="st"> </span>dt<span class="op">$</span>variable[<span class="kw">match</span>(att<span class="op">$</span>nodeID, dt<span class="op">$</span>nodeID)]</code></pre></div>
</div>
<div id="the-network-object-from-the-statnet-package" class="section level3">
<h3><span class="header-section-number">3.2.4</span> The network object from the <code>statnet</code>-package</h3>
<p>The <code>statnet</code>-package mainly works with a <code>network</code>-object. This means that once you have prepared your adjacency matrix (here named <code>mat</code>) and your attributes file (here named <code>att</code>) you have to create a nework object with which you can then work with.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">nw &lt;-<span class="st"> </span><span class="kw">network</span>(mat, <span class="dt">directed =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p>The <code>network()</code>-command takes various options. If you have a directed network, specify <code>directed = TRUE</code>, otherwise <code>directed = FALSE</code>.</p>
<p>The network object stores all your information on the network: the number of nodes, the number of edges, whether it’s a one-mode or two-mode network, whether it’s directed or not, etc.</p>
<p>For the Swiss national soccer team friendship network, the object looks like this:</p>
<pre><code>##  Network attributes:
##   vertices = 19 
##   directed = TRUE 
##   hyper = FALSE 
##   loops = FALSE 
##   multiple = FALSE 
##   bipartite = FALSE 
##   total edges= 27 
##     missing edges= 0 
##     non-missing edges= 27 
## 
##  Vertex attribute names: 
##     vertex.names 
## 
## No edge attributes</code></pre>
<p>You can see that the network contains 19 nodes (or vertices) and 27 edges (i.e., friendship ties).</p>
<p>It can also store your network attributes that you have saved in the <code>att</code>-data frame until now:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.vertex.attribute</span>(nw, <span class="st">&#39;gender&#39;</span>, att<span class="op">$</span>gender)
## or: 
nw <span class="op">%v%</span><span class="st"> &#39;gender&#39;</span> =<span class="st"> </span>att<span class="op">$</span>gender</code></pre></div>
<p>Now the variable <code>att$gender</code> is stored in the network <code>nw</code> and is labeled <code>gender</code>. You can give it whichever label you’d like, but make sure there are no spaces in between (this may cause errors later on).</p>
</div>
</div>
<div id="different-network-types-one-mode-and-two-mode-networks" class="section level2">
<h2><span class="header-section-number">3.3</span> Different Network types: one-mode and two-mode networks</h2>
<p>Two-mode networks consist of two disjoint sets of nodes (modes) with relations only possible between modes. For example, a two-mode network could illustrate associations between Swiss national soccer players and the clubs they played in between 2012 and 2014.</p>
<p><img src="mainimages/unnamed-chunk-22-1.png" width="672" /></p>
<p>A matrix storing ties for a two-mode network is rectangular and commonly referred to as an incidence or occurence matrix.</p>
<pre><code>##            FC Zürich GC FC Schaffhausen 1. FSV Mainz 05 FC St. Gallen
## Gavranovic         1  0               0               1             0
## Lang               0  1               0               0             1
## Bürki              0  1               1               0             0
## Schär              0  0               0               0             0
##            FC Wil FC Basel
## Gavranovic      0        0
## Lang            0        0
## Bürki           0        0
## Schär           1        1</code></pre>
<p>A projection onto a one-mode network can be achieved by multiplying the rectangular matrix by its transpose. Now players are connected based on whether they played together in the same clubs.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">one_mode_projection &lt;-<span class="st"> </span>bip_mat <span class="op">%*%</span><span class="st"> </span><span class="kw">t</span>(bip_mat)
<span class="kw">diag</span>(one_mode_projection) &lt;-<span class="st"> </span><span class="dv">0</span> <span class="co">#exclude self-ties</span>
one_mode_projection[<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>,<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>] <span class="co">#look at the first 10 players</span></code></pre></div>
<pre><code>##              Gavranovic Lang Bürki Schär Sommer Stocker Shaqiri Benaglio
## Gavranovic            0    0     0     0      0       0       0        0
## Lang                  0    0     1     0      1       0       0        0
## Bürki                 0    1     0     0      1       0       0        0
## Schär                 0    0     0     0      0       1       1        0
## Sommer                0    1     1     0      0       0       0        0
## Stocker               0    0     0     1      0       0       1        0
## Shaqiri               0    0     0     1      0       1       0        0
## Benaglio              0    0     0     0      0       0       0        0
## Xhaka                 0    0     0     1      1       1       1        0
## Lichtsteiner          0    0     0     0      0       0       0        0
##              Xhaka Lichtsteiner
## Gavranovic       0            0
## Lang             0            0
## Bürki            0            0
## Schär            1            0
## Sommer           1            0
## Stocker          1            0
## Shaqiri          1            0
## Benaglio         0            0
## Xhaka            0            0
## Lichtsteiner     0            0</code></pre>
<p><img src="mainimages/unnamed-chunk-25-1.png" width="672" /></p>
</div>
<div id="network-visualization" class="section level2">
<h2><span class="header-section-number">3.4</span> Network visualization</h2>
<div id="a-word-of-warning" class="section level3">
<h3><span class="header-section-number">3.4.1</span> A word of warning</h3>
<p>Network visualizations are at the same time pretty and dangerous. Be aware that nodes will always be placed on a canvas through an algorithm. The choice of a different algorithm can lead to a vastly different illustration. It is thus easy to convey substantive results that are just artefacts of the visualization procedure, for example regarding the centrality of actors. It is in your responsibility to use visualization to augment, not distort interpretation. If you read a network study engaging in “visual interpretation” - look for the numbers. Do they back up the story?</p>
</div>
<div id="resources-for-visualization" class="section level3">
<h3><span class="header-section-number">3.4.2</span> Resources for visualization</h3>
<p>For pretty graphs in R, ggnet2 is hard to beat. <a href="https://briatte.github.io/ggnet/" class="uri">https://briatte.github.io/ggnet/</a></p>
<p>For more advanced (and even prettier) visualizations, Gephi is a dedicated open source project (although somewhat buggy). <a href="https://gephi.org/" class="uri">https://gephi.org/</a></p>
<p>A third, java-based visualization tool is Visone. It is hard to beat when you want to look at different clusters in your network (but contains almost all other network visualization tools as well). <a href="https://visone.info" class="uri">https://visone.info</a></p>
</div>
<div id="a-brief-overview-over-ggnet2" class="section level3">
<h3><span class="header-section-number">3.4.3</span> A brief overview over ggnet2()</h3>
<p>The command <code>ggnet2()</code> can work with either the adjacency matrix and the attributes-data frame or with the network object.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggnet2</span>(friends_adjmat,
       <span class="dt">label =</span> <span class="ot">TRUE</span>,                     <span class="co"># should nodes be labeled?</span>
       <span class="dt">arrow.size =</span> <span class="dv">4</span>, <span class="dt">arrow.gap =</span> <span class="fl">0.04</span>, <span class="co"># set arrowheads</span>
       <span class="dt">node.color =</span> att<span class="op">$</span>Position,        <span class="co"># specify node colors</span>
       <span class="dt">palette =</span> <span class="st">&#39;Spectral&#39;</span>)             <span class="co"># use a pretty color-palette</span></code></pre></div>
<p><img src="mainimages/unnamed-chunk-26-1.png" width="672" /></p>
<p>Since all <code>ggnet()</code>-plots are <code>ggplots</code> you can add theme options that you usually use in ggplots:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggnet2</span>(friends_adjmat,
       <span class="dt">label =</span> <span class="ot">TRUE</span>,                     
       <span class="dt">arrow.size =</span> <span class="dv">4</span>, <span class="dt">arrow.gap =</span> <span class="fl">0.04</span>, 
       <span class="dt">node.color =</span> att<span class="op">$</span>Position,        
       <span class="dt">palette =</span> <span class="st">&#39;Spectral&#39;</span>) <span class="op">+</span><span class="st">   </span>
<span class="st">  </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">&#39;bottom&#39;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">&quot;Friendship network of the Swiss national soccer team&quot;</span>)</code></pre></div>
<p><img src="mainimages/unnamed-chunk-27-1.png" width="672" /></p>
<p>Plus you can save the plots using <code>ggsave()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggsave</span>(<span class="dt">file =</span> <span class="st">&#39;figures/nw_soccerCH.pdf&#39;</span>, <span class="dt">width =</span> <span class="dv">15</span>, <span class="dt">height =</span> <span class="dv">12</span>, <span class="dt">units =</span> <span class="st">&#39;cm&#39;</span>)</code></pre></div>

</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="intro.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="a-step-by-step-guide-to-computing-centrality-measures-in-statnet.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

</body>

</html>
